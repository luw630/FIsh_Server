// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Packet_Login.proto

#ifndef PROTOBUF_Packet_5fLogin_2eproto__INCLUDED
#define PROTOBUF_Packet_5fLogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Packet_Base.pb.h"
// @@protoc_insertion_point(includes)

namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Packet_5fLogin_2eproto();
void protobuf_AssignDesc_Packet_5fLogin_2eproto();
void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

class CS_Login;
class SC_LoginRst;
class CS_Register;
class SC_RegisterRst;
class CS_LoginGateWayOld;
class CS_LoginGateWay;
class SC_LoginGateWayRst;
class SC_PlayerOtherLogin;

enum emPacket_Login {
  EM_CS_Login = 257,
  EM_SC_LoginRst = 258,
  EM_CS_LoginGateWayOld = 259,
  EM_CS_LoginGateWay = 260,
  EM_SC_LoginGateWayRst = 261,
  EM_SC_PlayerOtherLogin = 262,
  EM_CS_Register = 263,
  EM_SC_RegisterRst = 264
};
bool emPacket_Login_IsValid(int value);
const emPacket_Login emPacket_Login_MIN = EM_CS_Login;
const emPacket_Login emPacket_Login_MAX = EM_SC_RegisterRst;
const int emPacket_Login_ARRAYSIZE = emPacket_Login_MAX + 1;

const ::google::protobuf::EnumDescriptor* emPacket_Login_descriptor();
inline const ::std::string& emPacket_Login_Name(emPacket_Login value) {
  return ::google::protobuf::internal::NameOfEnum(
    emPacket_Login_descriptor(), value);
}
inline bool emPacket_Login_Parse(
    const ::std::string& name, emPacket_Login* value) {
  return ::google::protobuf::internal::ParseNamedEnum<emPacket_Login>(
    emPacket_Login_descriptor(), name, value);
}
// ===================================================================

class CS_Login : public ::google::protobuf::Message {
 public:
  CS_Login();
  virtual ~CS_Login();

  CS_Login(const CS_Login& from);

  inline CS_Login& operator=(const CS_Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_Login& default_instance();

  void Swap(CS_Login* other);

  // implements Message ----------------------------------------------

  CS_Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_Login& from);
  void MergeFrom(const CS_Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_type = 1;
  inline bool has_m_type() const;
  inline void clear_m_type();
  static const int kMTypeFieldNumber = 1;
  inline ::google::protobuf::int32 m_type() const;
  inline void set_m_type(::google::protobuf::int32 value);

  // required string m_account = 2;
  inline bool has_m_account() const;
  inline void clear_m_account();
  static const int kMAccountFieldNumber = 2;
  inline const ::std::string& m_account() const;
  inline void set_m_account(const ::std::string& value);
  inline void set_m_account(const char* value);
  inline void set_m_account(const char* value, size_t size);
  inline ::std::string* mutable_m_account();
  inline ::std::string* release_m_account();
  inline void set_allocated_m_account(::std::string* m_account);

  // required string m_pwd = 3;
  inline bool has_m_pwd() const;
  inline void clear_m_pwd();
  static const int kMPwdFieldNumber = 3;
  inline const ::std::string& m_pwd() const;
  inline void set_m_pwd(const ::std::string& value);
  inline void set_m_pwd(const char* value);
  inline void set_m_pwd(const char* value, size_t size);
  inline ::std::string* mutable_m_pwd();
  inline ::std::string* release_m_pwd();
  inline void set_allocated_m_pwd(::std::string* m_pwd);

  // optional string m_param = 4;
  inline bool has_m_param() const;
  inline void clear_m_param();
  static const int kMParamFieldNumber = 4;
  inline const ::std::string& m_param() const;
  inline void set_m_param(const ::std::string& value);
  inline void set_m_param(const char* value);
  inline void set_m_param(const char* value, size_t size);
  inline ::std::string* mutable_m_param();
  inline ::std::string* release_m_param();
  inline void set_allocated_m_param(::std::string* m_param);

  // @@protoc_insertion_point(class_scope:rpc.CS_Login)
 private:
  inline void set_has_m_type();
  inline void clear_has_m_type();
  inline void set_has_m_account();
  inline void clear_has_m_account();
  inline void set_has_m_pwd();
  inline void clear_has_m_pwd();
  inline void set_has_m_param();
  inline void clear_has_m_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_account_;
  ::std::string* m_pwd_;
  ::std::string* m_param_;
  ::google::protobuf::int32 m_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static CS_Login* default_instance_;
};
// -------------------------------------------------------------------

class SC_LoginRst : public ::google::protobuf::Message {
 public:
  SC_LoginRst();
  virtual ~SC_LoginRst();

  SC_LoginRst(const SC_LoginRst& from);

  inline SC_LoginRst& operator=(const SC_LoginRst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_LoginRst& default_instance();

  void Swap(SC_LoginRst* other);

  // implements Message ----------------------------------------------

  SC_LoginRst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_LoginRst& from);
  void MergeFrom(const SC_LoginRst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_rst = 1;
  inline bool has_m_rst() const;
  inline void clear_m_rst();
  static const int kMRstFieldNumber = 1;
  inline ::google::protobuf::int32 m_rst() const;
  inline void set_m_rst(::google::protobuf::int32 value);

  // optional string m_sessionid = 2;
  inline bool has_m_sessionid() const;
  inline void clear_m_sessionid();
  static const int kMSessionidFieldNumber = 2;
  inline const ::std::string& m_sessionid() const;
  inline void set_m_sessionid(const ::std::string& value);
  inline void set_m_sessionid(const char* value);
  inline void set_m_sessionid(const char* value, size_t size);
  inline ::std::string* mutable_m_sessionid();
  inline ::std::string* release_m_sessionid();
  inline void set_allocated_m_sessionid(::std::string* m_sessionid);

  // @@protoc_insertion_point(class_scope:rpc.SC_LoginRst)
 private:
  inline void set_has_m_rst();
  inline void clear_has_m_rst();
  inline void set_has_m_sessionid();
  inline void clear_has_m_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_sessionid_;
  ::google::protobuf::int32 m_rst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static SC_LoginRst* default_instance_;
};
// -------------------------------------------------------------------

class CS_Register : public ::google::protobuf::Message {
 public:
  CS_Register();
  virtual ~CS_Register();

  CS_Register(const CS_Register& from);

  inline CS_Register& operator=(const CS_Register& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_Register& default_instance();

  void Swap(CS_Register* other);

  // implements Message ----------------------------------------------

  CS_Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_Register& from);
  void MergeFrom(const CS_Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_account = 1;
  inline bool has_m_account() const;
  inline void clear_m_account();
  static const int kMAccountFieldNumber = 1;
  inline const ::std::string& m_account() const;
  inline void set_m_account(const ::std::string& value);
  inline void set_m_account(const char* value);
  inline void set_m_account(const char* value, size_t size);
  inline ::std::string* mutable_m_account();
  inline ::std::string* release_m_account();
  inline void set_allocated_m_account(::std::string* m_account);

  // required string m_pwd = 2;
  inline bool has_m_pwd() const;
  inline void clear_m_pwd();
  static const int kMPwdFieldNumber = 2;
  inline const ::std::string& m_pwd() const;
  inline void set_m_pwd(const ::std::string& value);
  inline void set_m_pwd(const char* value);
  inline void set_m_pwd(const char* value, size_t size);
  inline ::std::string* mutable_m_pwd();
  inline ::std::string* release_m_pwd();
  inline void set_allocated_m_pwd(::std::string* m_pwd);

  // @@protoc_insertion_point(class_scope:rpc.CS_Register)
 private:
  inline void set_has_m_account();
  inline void clear_has_m_account();
  inline void set_has_m_pwd();
  inline void clear_has_m_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_account_;
  ::std::string* m_pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static CS_Register* default_instance_;
};
// -------------------------------------------------------------------

class SC_RegisterRst : public ::google::protobuf::Message {
 public:
  SC_RegisterRst();
  virtual ~SC_RegisterRst();

  SC_RegisterRst(const SC_RegisterRst& from);

  inline SC_RegisterRst& operator=(const SC_RegisterRst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_RegisterRst& default_instance();

  void Swap(SC_RegisterRst* other);

  // implements Message ----------------------------------------------

  SC_RegisterRst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_RegisterRst& from);
  void MergeFrom(const SC_RegisterRst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_rst = 1;
  inline bool has_m_rst() const;
  inline void clear_m_rst();
  static const int kMRstFieldNumber = 1;
  inline ::google::protobuf::int32 m_rst() const;
  inline void set_m_rst(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.SC_RegisterRst)
 private:
  inline void set_has_m_rst();
  inline void clear_has_m_rst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_rst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static SC_RegisterRst* default_instance_;
};
// -------------------------------------------------------------------

class CS_LoginGateWayOld : public ::google::protobuf::Message {
 public:
  CS_LoginGateWayOld();
  virtual ~CS_LoginGateWayOld();

  CS_LoginGateWayOld(const CS_LoginGateWayOld& from);

  inline CS_LoginGateWayOld& operator=(const CS_LoginGateWayOld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_LoginGateWayOld& default_instance();

  void Swap(CS_LoginGateWayOld* other);

  // implements Message ----------------------------------------------

  CS_LoginGateWayOld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_LoginGateWayOld& from);
  void MergeFrom(const CS_LoginGateWayOld& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_account = 1;
  inline bool has_m_account() const;
  inline void clear_m_account();
  static const int kMAccountFieldNumber = 1;
  inline const ::std::string& m_account() const;
  inline void set_m_account(const ::std::string& value);
  inline void set_m_account(const char* value);
  inline void set_m_account(const char* value, size_t size);
  inline ::std::string* mutable_m_account();
  inline ::std::string* release_m_account();
  inline void set_allocated_m_account(::std::string* m_account);

  // @@protoc_insertion_point(class_scope:rpc.CS_LoginGateWayOld)
 private:
  inline void set_has_m_account();
  inline void clear_has_m_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static CS_LoginGateWayOld* default_instance_;
};
// -------------------------------------------------------------------

class CS_LoginGateWay : public ::google::protobuf::Message {
 public:
  CS_LoginGateWay();
  virtual ~CS_LoginGateWay();

  CS_LoginGateWay(const CS_LoginGateWay& from);

  inline CS_LoginGateWay& operator=(const CS_LoginGateWay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CS_LoginGateWay& default_instance();

  void Swap(CS_LoginGateWay* other);

  // implements Message ----------------------------------------------

  CS_LoginGateWay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CS_LoginGateWay& from);
  void MergeFrom(const CS_LoginGateWay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_sessionid = 1;
  inline bool has_m_sessionid() const;
  inline void clear_m_sessionid();
  static const int kMSessionidFieldNumber = 1;
  inline const ::std::string& m_sessionid() const;
  inline void set_m_sessionid(const ::std::string& value);
  inline void set_m_sessionid(const char* value);
  inline void set_m_sessionid(const char* value, size_t size);
  inline ::std::string* mutable_m_sessionid();
  inline ::std::string* release_m_sessionid();
  inline void set_allocated_m_sessionid(::std::string* m_sessionid);

  // @@protoc_insertion_point(class_scope:rpc.CS_LoginGateWay)
 private:
  inline void set_has_m_sessionid();
  inline void clear_has_m_sessionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_sessionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static CS_LoginGateWay* default_instance_;
};
// -------------------------------------------------------------------

class SC_LoginGateWayRst : public ::google::protobuf::Message {
 public:
  SC_LoginGateWayRst();
  virtual ~SC_LoginGateWayRst();

  SC_LoginGateWayRst(const SC_LoginGateWayRst& from);

  inline SC_LoginGateWayRst& operator=(const SC_LoginGateWayRst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_LoginGateWayRst& default_instance();

  void Swap(SC_LoginGateWayRst* other);

  // implements Message ----------------------------------------------

  SC_LoginGateWayRst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_LoginGateWayRst& from);
  void MergeFrom(const SC_LoginGateWayRst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_rst = 1;
  inline bool has_m_rst() const;
  inline void clear_m_rst();
  static const int kMRstFieldNumber = 1;
  inline ::google::protobuf::int32 m_rst() const;
  inline void set_m_rst(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:rpc.SC_LoginGateWayRst)
 private:
  inline void set_has_m_rst();
  inline void clear_has_m_rst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_rst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static SC_LoginGateWayRst* default_instance_;
};
// -------------------------------------------------------------------

class SC_PlayerOtherLogin : public ::google::protobuf::Message {
 public:
  SC_PlayerOtherLogin();
  virtual ~SC_PlayerOtherLogin();

  SC_PlayerOtherLogin(const SC_PlayerOtherLogin& from);

  inline SC_PlayerOtherLogin& operator=(const SC_PlayerOtherLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SC_PlayerOtherLogin& default_instance();

  void Swap(SC_PlayerOtherLogin* other);

  // implements Message ----------------------------------------------

  SC_PlayerOtherLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SC_PlayerOtherLogin& from);
  void MergeFrom(const SC_PlayerOtherLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_info = 1;
  inline bool has_m_info() const;
  inline void clear_m_info();
  static const int kMInfoFieldNumber = 1;
  inline const ::std::string& m_info() const;
  inline void set_m_info(const ::std::string& value);
  inline void set_m_info(const char* value);
  inline void set_m_info(const char* value, size_t size);
  inline ::std::string* mutable_m_info();
  inline ::std::string* release_m_info();
  inline void set_allocated_m_info(::std::string* m_info);

  // @@protoc_insertion_point(class_scope:rpc.SC_PlayerOtherLogin)
 private:
  inline void set_has_m_info();
  inline void clear_has_m_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Packet_5fLogin_2eproto();
  friend void protobuf_AssignDesc_Packet_5fLogin_2eproto();
  friend void protobuf_ShutdownFile_Packet_5fLogin_2eproto();

  void InitAsDefaultInstance();
  static SC_PlayerOtherLogin* default_instance_;
};
// ===================================================================


// ===================================================================

// CS_Login

// required int32 m_type = 1;
inline bool CS_Login::has_m_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_Login::set_has_m_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_Login::clear_has_m_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_Login::clear_m_type() {
  m_type_ = 0;
  clear_has_m_type();
}
inline ::google::protobuf::int32 CS_Login::m_type() const {
  return m_type_;
}
inline void CS_Login::set_m_type(::google::protobuf::int32 value) {
  set_has_m_type();
  m_type_ = value;
}

// required string m_account = 2;
inline bool CS_Login::has_m_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CS_Login::set_has_m_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CS_Login::clear_has_m_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CS_Login::clear_m_account() {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    m_account_->clear();
  }
  clear_has_m_account();
}
inline const ::std::string& CS_Login::m_account() const {
  return *m_account_;
}
inline void CS_Login::set_m_account(const ::std::string& value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_Login::set_m_account(const char* value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_Login::set_m_account(const char* value, size_t size) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_Login::mutable_m_account() {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  return m_account_;
}
inline ::std::string* CS_Login::release_m_account() {
  clear_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_account_;
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_Login::set_allocated_m_account(::std::string* m_account) {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    delete m_account_;
  }
  if (m_account) {
    set_has_m_account();
    m_account_ = m_account;
  } else {
    clear_has_m_account();
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string m_pwd = 3;
inline bool CS_Login::has_m_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CS_Login::set_has_m_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CS_Login::clear_has_m_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CS_Login::clear_m_pwd() {
  if (m_pwd_ != &::google::protobuf::internal::kEmptyString) {
    m_pwd_->clear();
  }
  clear_has_m_pwd();
}
inline const ::std::string& CS_Login::m_pwd() const {
  return *m_pwd_;
}
inline void CS_Login::set_m_pwd(const ::std::string& value) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(value);
}
inline void CS_Login::set_m_pwd(const char* value) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(value);
}
inline void CS_Login::set_m_pwd(const char* value, size_t size) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_Login::mutable_m_pwd() {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  return m_pwd_;
}
inline ::std::string* CS_Login::release_m_pwd() {
  clear_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_pwd_;
    m_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_Login::set_allocated_m_pwd(::std::string* m_pwd) {
  if (m_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete m_pwd_;
  }
  if (m_pwd) {
    set_has_m_pwd();
    m_pwd_ = m_pwd;
  } else {
    clear_has_m_pwd();
    m_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string m_param = 4;
inline bool CS_Login::has_m_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CS_Login::set_has_m_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CS_Login::clear_has_m_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CS_Login::clear_m_param() {
  if (m_param_ != &::google::protobuf::internal::kEmptyString) {
    m_param_->clear();
  }
  clear_has_m_param();
}
inline const ::std::string& CS_Login::m_param() const {
  return *m_param_;
}
inline void CS_Login::set_m_param(const ::std::string& value) {
  set_has_m_param();
  if (m_param_ == &::google::protobuf::internal::kEmptyString) {
    m_param_ = new ::std::string;
  }
  m_param_->assign(value);
}
inline void CS_Login::set_m_param(const char* value) {
  set_has_m_param();
  if (m_param_ == &::google::protobuf::internal::kEmptyString) {
    m_param_ = new ::std::string;
  }
  m_param_->assign(value);
}
inline void CS_Login::set_m_param(const char* value, size_t size) {
  set_has_m_param();
  if (m_param_ == &::google::protobuf::internal::kEmptyString) {
    m_param_ = new ::std::string;
  }
  m_param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_Login::mutable_m_param() {
  set_has_m_param();
  if (m_param_ == &::google::protobuf::internal::kEmptyString) {
    m_param_ = new ::std::string;
  }
  return m_param_;
}
inline ::std::string* CS_Login::release_m_param() {
  clear_has_m_param();
  if (m_param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_param_;
    m_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_Login::set_allocated_m_param(::std::string* m_param) {
  if (m_param_ != &::google::protobuf::internal::kEmptyString) {
    delete m_param_;
  }
  if (m_param) {
    set_has_m_param();
    m_param_ = m_param;
  } else {
    clear_has_m_param();
    m_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SC_LoginRst

// required int32 m_rst = 1;
inline bool SC_LoginRst::has_m_rst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_LoginRst::set_has_m_rst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_LoginRst::clear_has_m_rst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_LoginRst::clear_m_rst() {
  m_rst_ = 0;
  clear_has_m_rst();
}
inline ::google::protobuf::int32 SC_LoginRst::m_rst() const {
  return m_rst_;
}
inline void SC_LoginRst::set_m_rst(::google::protobuf::int32 value) {
  set_has_m_rst();
  m_rst_ = value;
}

// optional string m_sessionid = 2;
inline bool SC_LoginRst::has_m_sessionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SC_LoginRst::set_has_m_sessionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SC_LoginRst::clear_has_m_sessionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SC_LoginRst::clear_m_sessionid() {
  if (m_sessionid_ != &::google::protobuf::internal::kEmptyString) {
    m_sessionid_->clear();
  }
  clear_has_m_sessionid();
}
inline const ::std::string& SC_LoginRst::m_sessionid() const {
  return *m_sessionid_;
}
inline void SC_LoginRst::set_m_sessionid(const ::std::string& value) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(value);
}
inline void SC_LoginRst::set_m_sessionid(const char* value) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(value);
}
inline void SC_LoginRst::set_m_sessionid(const char* value, size_t size) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SC_LoginRst::mutable_m_sessionid() {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  return m_sessionid_;
}
inline ::std::string* SC_LoginRst::release_m_sessionid() {
  clear_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sessionid_;
    m_sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SC_LoginRst::set_allocated_m_sessionid(::std::string* m_sessionid) {
  if (m_sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete m_sessionid_;
  }
  if (m_sessionid) {
    set_has_m_sessionid();
    m_sessionid_ = m_sessionid;
  } else {
    clear_has_m_sessionid();
    m_sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CS_Register

// required string m_account = 1;
inline bool CS_Register::has_m_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_Register::set_has_m_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_Register::clear_has_m_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_Register::clear_m_account() {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    m_account_->clear();
  }
  clear_has_m_account();
}
inline const ::std::string& CS_Register::m_account() const {
  return *m_account_;
}
inline void CS_Register::set_m_account(const ::std::string& value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_Register::set_m_account(const char* value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_Register::set_m_account(const char* value, size_t size) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_Register::mutable_m_account() {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  return m_account_;
}
inline ::std::string* CS_Register::release_m_account() {
  clear_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_account_;
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_Register::set_allocated_m_account(::std::string* m_account) {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    delete m_account_;
  }
  if (m_account) {
    set_has_m_account();
    m_account_ = m_account;
  } else {
    clear_has_m_account();
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string m_pwd = 2;
inline bool CS_Register::has_m_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CS_Register::set_has_m_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CS_Register::clear_has_m_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CS_Register::clear_m_pwd() {
  if (m_pwd_ != &::google::protobuf::internal::kEmptyString) {
    m_pwd_->clear();
  }
  clear_has_m_pwd();
}
inline const ::std::string& CS_Register::m_pwd() const {
  return *m_pwd_;
}
inline void CS_Register::set_m_pwd(const ::std::string& value) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(value);
}
inline void CS_Register::set_m_pwd(const char* value) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(value);
}
inline void CS_Register::set_m_pwd(const char* value, size_t size) {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  m_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_Register::mutable_m_pwd() {
  set_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    m_pwd_ = new ::std::string;
  }
  return m_pwd_;
}
inline ::std::string* CS_Register::release_m_pwd() {
  clear_has_m_pwd();
  if (m_pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_pwd_;
    m_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_Register::set_allocated_m_pwd(::std::string* m_pwd) {
  if (m_pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete m_pwd_;
  }
  if (m_pwd) {
    set_has_m_pwd();
    m_pwd_ = m_pwd;
  } else {
    clear_has_m_pwd();
    m_pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SC_RegisterRst

// required int32 m_rst = 1;
inline bool SC_RegisterRst::has_m_rst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_RegisterRst::set_has_m_rst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_RegisterRst::clear_has_m_rst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_RegisterRst::clear_m_rst() {
  m_rst_ = 0;
  clear_has_m_rst();
}
inline ::google::protobuf::int32 SC_RegisterRst::m_rst() const {
  return m_rst_;
}
inline void SC_RegisterRst::set_m_rst(::google::protobuf::int32 value) {
  set_has_m_rst();
  m_rst_ = value;
}

// -------------------------------------------------------------------

// CS_LoginGateWayOld

// required string m_account = 1;
inline bool CS_LoginGateWayOld::has_m_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_LoginGateWayOld::set_has_m_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_LoginGateWayOld::clear_has_m_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_LoginGateWayOld::clear_m_account() {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    m_account_->clear();
  }
  clear_has_m_account();
}
inline const ::std::string& CS_LoginGateWayOld::m_account() const {
  return *m_account_;
}
inline void CS_LoginGateWayOld::set_m_account(const ::std::string& value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_LoginGateWayOld::set_m_account(const char* value) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(value);
}
inline void CS_LoginGateWayOld::set_m_account(const char* value, size_t size) {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  m_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_LoginGateWayOld::mutable_m_account() {
  set_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    m_account_ = new ::std::string;
  }
  return m_account_;
}
inline ::std::string* CS_LoginGateWayOld::release_m_account() {
  clear_has_m_account();
  if (m_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_account_;
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_LoginGateWayOld::set_allocated_m_account(::std::string* m_account) {
  if (m_account_ != &::google::protobuf::internal::kEmptyString) {
    delete m_account_;
  }
  if (m_account) {
    set_has_m_account();
    m_account_ = m_account;
  } else {
    clear_has_m_account();
    m_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CS_LoginGateWay

// required string m_sessionid = 1;
inline bool CS_LoginGateWay::has_m_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CS_LoginGateWay::set_has_m_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CS_LoginGateWay::clear_has_m_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CS_LoginGateWay::clear_m_sessionid() {
  if (m_sessionid_ != &::google::protobuf::internal::kEmptyString) {
    m_sessionid_->clear();
  }
  clear_has_m_sessionid();
}
inline const ::std::string& CS_LoginGateWay::m_sessionid() const {
  return *m_sessionid_;
}
inline void CS_LoginGateWay::set_m_sessionid(const ::std::string& value) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(value);
}
inline void CS_LoginGateWay::set_m_sessionid(const char* value) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(value);
}
inline void CS_LoginGateWay::set_m_sessionid(const char* value, size_t size) {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  m_sessionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CS_LoginGateWay::mutable_m_sessionid() {
  set_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    m_sessionid_ = new ::std::string;
  }
  return m_sessionid_;
}
inline ::std::string* CS_LoginGateWay::release_m_sessionid() {
  clear_has_m_sessionid();
  if (m_sessionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_sessionid_;
    m_sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CS_LoginGateWay::set_allocated_m_sessionid(::std::string* m_sessionid) {
  if (m_sessionid_ != &::google::protobuf::internal::kEmptyString) {
    delete m_sessionid_;
  }
  if (m_sessionid) {
    set_has_m_sessionid();
    m_sessionid_ = m_sessionid;
  } else {
    clear_has_m_sessionid();
    m_sessionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SC_LoginGateWayRst

// required int32 m_rst = 1;
inline bool SC_LoginGateWayRst::has_m_rst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_LoginGateWayRst::set_has_m_rst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_LoginGateWayRst::clear_has_m_rst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_LoginGateWayRst::clear_m_rst() {
  m_rst_ = 0;
  clear_has_m_rst();
}
inline ::google::protobuf::int32 SC_LoginGateWayRst::m_rst() const {
  return m_rst_;
}
inline void SC_LoginGateWayRst::set_m_rst(::google::protobuf::int32 value) {
  set_has_m_rst();
  m_rst_ = value;
}

// -------------------------------------------------------------------

// SC_PlayerOtherLogin

// required string m_info = 1;
inline bool SC_PlayerOtherLogin::has_m_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SC_PlayerOtherLogin::set_has_m_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SC_PlayerOtherLogin::clear_has_m_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SC_PlayerOtherLogin::clear_m_info() {
  if (m_info_ != &::google::protobuf::internal::kEmptyString) {
    m_info_->clear();
  }
  clear_has_m_info();
}
inline const ::std::string& SC_PlayerOtherLogin::m_info() const {
  return *m_info_;
}
inline void SC_PlayerOtherLogin::set_m_info(const ::std::string& value) {
  set_has_m_info();
  if (m_info_ == &::google::protobuf::internal::kEmptyString) {
    m_info_ = new ::std::string;
  }
  m_info_->assign(value);
}
inline void SC_PlayerOtherLogin::set_m_info(const char* value) {
  set_has_m_info();
  if (m_info_ == &::google::protobuf::internal::kEmptyString) {
    m_info_ = new ::std::string;
  }
  m_info_->assign(value);
}
inline void SC_PlayerOtherLogin::set_m_info(const char* value, size_t size) {
  set_has_m_info();
  if (m_info_ == &::google::protobuf::internal::kEmptyString) {
    m_info_ = new ::std::string;
  }
  m_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SC_PlayerOtherLogin::mutable_m_info() {
  set_has_m_info();
  if (m_info_ == &::google::protobuf::internal::kEmptyString) {
    m_info_ = new ::std::string;
  }
  return m_info_;
}
inline ::std::string* SC_PlayerOtherLogin::release_m_info() {
  clear_has_m_info();
  if (m_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_info_;
    m_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SC_PlayerOtherLogin::set_allocated_m_info(::std::string* m_info) {
  if (m_info_ != &::google::protobuf::internal::kEmptyString) {
    delete m_info_;
  }
  if (m_info) {
    set_has_m_info();
    m_info_ = m_info;
  } else {
    clear_has_m_info();
    m_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc::emPacket_Login>() {
  return ::rpc::emPacket_Login_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Packet_5fLogin_2eproto__INCLUDED
